#include <cassert>

#include <Miami/Evan/Logger.hpp>

#include <Miami/Richard/Table.hpp>

namespace Miami::Richard
{
Table::Table (Disco::Context *multithreadingContext, AnyDataId id, std::string name)
    : id_ (id),
      guard_ (multithreadingContext),
      name_ (std::move (name)),

      columns_ (),
      indices_ (),
      rows_ (),

      nextColumnId_ (0),
      nextIndexId_ (0),
      nextRowId_ (0)
{
}

AnyDataId Table::GetId () const
{
    return id_;
}

Disco::ReadWriteGuard &Table::ReadWriteGuard ()
{
    return guard_;
}

ResultCode Table::GetName (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard, std::string &output) const
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    output = name_;
    return ResultCode::OK;
}

ResultCode Table::CreateReadCursor (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard, AnyDataId indexId,
                                    TableReadCursor *&output)
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    // TODO: Implement.
    return ResultCode::OK;
}

ResultCode Table::GetColumnsIds (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard,
                                 std::vector <AnyDataId> &output) const
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    for (const auto &idColumnPair : columns_)
    {
        output.emplace_back (idColumnPair.first);
    }

    return ResultCode::OK;
}

ResultCode Table::GetColumnInfo (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard,
                                 AnyDataId id, ColumnInfo &output) const
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    auto iterator = columns_.find (id);

    if (iterator == columns_.end ())
    {
        return ResultCode::COLUMN_WITH_GIVEN_ID_NOT_FOUND;
    }
    else
    {
        output = iterator->second.GetColumnInfo ();
        return ResultCode::OK;
    }
}

ResultCode Table::GetIndicesIds (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard,
                                 std::vector <AnyDataId> &output) const
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    for (const auto &idIndexPair : indices_)
    {
        output.emplace_back (idIndexPair.first);
    }

    return ResultCode::OK;
}

ResultCode Table::GetIndexInfo (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard,
                                AnyDataId id, IndexInfo &output) const
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    auto iterator = indices_.find (id);

    if (iterator == indices_.end ())
    {
        return ResultCode::INDEX_WITH_GIVEN_ID_NOT_FOUND;
    }
    else
    {
        output = iterator->second.GetIndexInfo ();
        return ResultCode::OK;
    }
}

ResultCode Table::SetName (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard, const std::string &name)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    if (name.empty ())
    {
        return ResultCode::TABLE_NAME_SHOULD_NOT_BE_EMPTY;
    }
    else
    {
        name_ = name;
        return ResultCode::OK;
    }
}

ResultCode Table::CreateEditCursor (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard, AnyDataId indexId,
                                    TableEditCursor *&output)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    // TODO: Implement.
    return ResultCode::OK;
}

ResultCode Table::AddColumn (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard, const ColumnInfo &info)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    if (info.name_.empty ())
    {
        return ResultCode::COLUMN_NAME_SHOULD_NOT_BE_EMPTY;
    }

    AnyDataId columnId = nextColumnId_++;
    if (columns_.count (columnId) > 0)
    {
        Evan::Logger::Get ().Log (Evan::LogLevel::ERROR, "Unable to add column to table \"" + name_ +
                                                         "\", because autogenerated column id is already used!");
        return ResultCode::INVARIANTS_VIOLATED;
    }
    else
    {
        auto result = columns_.emplace (columnId, ColumnInfo {columnId, info.dataType_, info.name_});
        if (result.second)
        {
            return ResultCode::OK;
        }
        else
        {
            Evan::Logger::Get ().Log (Evan::LogLevel::ERROR, "Unable to add column to table \"" + name_ +
                                                             "\", because emplace operation failed!");
            return ResultCode::INVARIANTS_VIOLATED;
        }
    }
}

ResultCode Table::RemoveColumn (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard, AnyDataId id)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    auto iterator = columns_.find (id);
    if (iterator == columns_.end ())
    {
        return ResultCode::COLUMN_WITH_GIVEN_ID_NOT_FOUND;
    }
    else
    {
        // Column removal is rare operation, so it's ok to iterate over all indices.
        std::vector <AnyDataId> cascadeIndices;

        for (auto &idIndexPair : indices_)
        {
            auto columnIdInIndex = std::find (idIndexPair.second.GetIndexInfo ().columns_.begin (),
                                              idIndexPair.second.GetIndexInfo ().columns_.end (), id);

            if (columnIdInIndex != idIndexPair.second.GetIndexInfo ().columns_.end ())
            {
                if (!idIndexPair.second.IsSafeToRemove (writeGuard))
                {
                    return ResultCode::COLUMN_REMOVAL_BLOCKED_BY_DEPENDANT_INDEX;
                }

                cascadeIndices.emplace_back (idIndexPair.first);
            }
        }

        columns_.erase (iterator);
        for (AnyDataId indexId : cascadeIndices)
        {
            indices_.erase (indexId);
        }

        return ResultCode::OK;
    }
}

ResultCode Table::AddIndex (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard, const IndexInfo &info)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    if (info.name_.empty ())
    {
        return ResultCode::INDEX_NAME_SHOULD_NOT_BE_EMPTY;
    }

    if (info.columns_.empty ())
    {
        return ResultCode::INDEX_MUST_DEPEND_ON_AT_LEAST_ONE_COLUMN;
    }

    for (AnyDataId columnId : info.columns_)
    {
        if (columns_.count (columnId) == 0)
        {
            Evan::Logger::Get ().Log (
                Evan::LogLevel::ERROR,
                "Unable to add index to table \"" + name_ + "\", because column with requested id " +
                std::to_string (columnId) + " is not found!");
            return ResultCode::COLUMN_WITH_GIVEN_ID_NOT_FOUND;
        }
    }

    AnyDataId indexId = nextIndexId_++;
    if (indices_.count (indexId) > 0)
    {
        Evan::Logger::Get ().Log (Evan::LogLevel::ERROR, "Unable to add index to table \"" + name_ +
                                                         "\", because autogenerated index id is already used!");
        return ResultCode::INVARIANTS_VIOLATED;
    }
    else
    {
        auto result = indices_.emplace (
            indexId, std::make_pair (this, IndexInfo {indexId, info.name_, info.columns_}));

        if (result.second)
        {
            return ResultCode::OK;
        }
        else
        {
            Evan::Logger::Get ().Log (Evan::LogLevel::ERROR, "Unable to add index to table \"" + name_ +
                                                             "\", because emplace operation failed!");
            return ResultCode::INVARIANTS_VIOLATED;
        }
    }
}

ResultCode Table::RemoveIndex (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard, AnyDataId id)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    auto iterator = indices_.find (id);
    if (iterator == indices_.end ())
    {
        return ResultCode::INDEX_WITH_GIVEN_ID_NOT_FOUND;
    }
    else
    {
        if (iterator->second.IsSafeToRemove (writeGuard))
        {
            indices_.erase (iterator);
            return ResultCode::OK;
        }
        else
        {
            return ResultCode::INDEX_REMOVAL_BLOCKED_BY_DEPENDANT_CURSORS;
        }
    }
}

ResultCode Table::InsertRow (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard,
                             std::unordered_map <AnyDataId, AnyDataContainer> &values)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    // TODO: Implement.
    return ResultCode::OK;
}

bool Table::CheckReadOrWriteGuard (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard) const
{
    if (readOrWriteGuard == nullptr || !(readOrWriteGuard->Is (&guard_.Read ()) ||
                                         readOrWriteGuard->Is (&guard_.Write ())))
    {
        Evan::Logger::Get ().Log (Evan::LogLevel::ERROR, "Caught attempt to read table \"" + name_ +
                                                         "\" data without proper read or write guard!");
        assert (false);
        return false;
    }
    else
    {
        return true;
    }
}

bool Table::CheckWriteGuard (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard) const
{
    if (writeGuard == nullptr || !writeGuard->Is (&guard_.Write ()))
    {
        Evan::Logger::Get ().Log (Evan::LogLevel::ERROR, "Caught attempt to edit table \"" + name_ +
                                                         "\" data without proper write guard!");
        assert (false);
        return false;
    }
    else
    {
        return true;
    }
}

AnyDataContainer *Table::GetColumnValue (AnyDataId columnId, AnyDataId rowId)
{
    auto columnIterator = columns_.find (columnId);
    if (columnIterator == columns_.end ())
    {
        return nullptr;
    }

    auto rowIterator = columnIterator->second.values_.find (rowId);
    if (rowIterator == columnIterator->second.values_.end ())
    {
        return nullptr;
    }

    return &rowIterator->second;
}
}
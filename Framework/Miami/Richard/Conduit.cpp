#include <cassert>

#include <Miami/Evan/Logger.hpp>

#include <Miami/Richard/Conduit.hpp>

namespace Miami::Richard
{
Conduit::Conduit (Disco::Context *multithreadingContext)
    : guard_ (multithreadingContext),
      tables_ (),
      nextTableId_ (0)
{
}

Disco::ReadWriteGuard &Conduit::ReadWriteGuard ()
{
    return guard_;
}

ResultCode Conduit::GetTableIds (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard,
                                 std::vector <AnyDataId> &output) const
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    for (const auto &idTablePair : tables_)
    {
        output.emplace_back (idTablePair.first);
    }

    return ResultCode::OK;
}

ResultCode Conduit::GetTable (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard,
                              AnyDataId id, Table *&output)
{
    if (!CheckReadOrWriteGuard (readOrWriteGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    auto iterator = tables_.find (id);
    if (iterator == tables_.end ())
    {
        return ResultCode::TABLE_WITH_GIVEN_ID_NOT_FOUND;
    }
    else
    {
        output = iterator->second.get ();
        return ResultCode::OK;
    }
}

ResultCode Conduit::AddTable (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard, const std::string &name,
                              AnyDataId &outputId)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    if (name.empty ())
    {
        return ResultCode::TABLE_NAME_SHOULD_NOT_BE_EMPTY;
    }

    AnyDataId tableId = nextTableId_++;
    if (tables_.count (tableId) > 0)
    {
        Evan::Logger::Get ().Log (
            Evan::LogLevel::ERROR,
            "Unable to add table to conduit, because autogenerated table id is already used!");

        assert (false);
        return ResultCode::INVARIANTS_VIOLATED;
    }
    else
    {
        outputId = tableId;
        auto result = tables_.emplace (
            tableId, std::make_unique <Table> (guard_.Write ().GetContext (), tableId, name));

        if (result.second)
        {
            return ResultCode::OK;
        }
        else
        {
            Evan::Logger::Get ().Log (
                Evan::LogLevel::ERROR,
                "Unable to add table to conduit, because emplace operation failed!");

            assert (false);
            return ResultCode::INVARIANTS_VIOLATED;
        }
    }
}

ResultCode Conduit::RemoveTable (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard,
                                 const std::shared_ptr <Disco::SafeLockGuard> &tableWriteGuard, AnyDataId tableId)
{
    if (!CheckWriteGuard (writeGuard))
    {
        return ResultCode::INVARIANTS_VIOLATED;
    }

    auto iterator = tables_.find (tableId);
    if (iterator == tables_.end ())
    {
        return ResultCode::TABLE_WITH_GIVEN_ID_NOT_FOUND;
    }
    else
    {
        assert(iterator->second);
        if (!iterator->second || iterator->second->IsSafeToRemove (tableWriteGuard))
        {
            tables_.erase (iterator);
            return ResultCode::OK;
        }
        else
        {
            return ResultCode::TABLE_REMOVAL_BLOCKED;
        }
    }
}

bool Conduit::CheckReadOrWriteGuard (const std::shared_ptr <Disco::SafeLockGuard> &readOrWriteGuard) const
{
    if (Disco::IsReadOrWriteCaptured (readOrWriteGuard, guard_))
    {
        return true;
    }
    else
    {
        Evan::Logger::Get ().Log (Evan::LogLevel::ERROR,
                                  "Caught attempt to read conduit data without proper read or write guard!");
        assert (false);
        return false;
    }
}

bool Conduit::CheckWriteGuard (const std::shared_ptr <Disco::SafeLockGuard> &writeGuard) const
{
    if (Disco::IsWriteCaptured (writeGuard, guard_))
    {
        return true;
    }
    else
    {
        Evan::Logger::Get ().Log (Evan::LogLevel::ERROR,
                                  "Caught attempt to edit conduit data without proper write guard!");
        assert (false);
        return false;
    }
}
}